# Exercise 06

When attempting to sort an array of various lengths, we are surprised to see that an ArgumentError is raised. Make the necessary changes to our code so that the various lengths can be properly sorted and line 62 produces the expected output.

```ruby
class Length
  # Added:
  include Comparable

  attr_reader :value, :unit

  def initialize(value, unit)
    @value = value
    @unit = unit
  end

  def as_kilometers
    convert_to(:km, { km: 1, mi: 0.6213711, nmi: 0.539957 })
  end

  def as_miles
    convert_to(:mi, { km: 1.609344, mi: 1, nmi: 0.8689762419 })
  end

  def as_nautical_miles
    convert_to(:nmi, { km: 1.8519993, mi: 1.15078, nmi: 1 })
  end

  # Added:
  def <=>(other)
    case unit
    when :km  then value <=> other.as_kilometers.value
    when :mi  then value <=> other.as_miles.value
    when :nmi then value <=> other.as_nautical_miles.value
    end
  end

  # def ==(other)
  #   case unit
  #   when :km  then value == other.as_kilometers.value
  #   when :mi  then value == other.as_miles.value
  #   when :nmi then value == other.as_nautical_miles.value
  #   end
  # end

  # def <(other)
  #   case unit
  #   when :km  then value < other.as_kilometers.value
  #   when :mi  then value < other.as_miles.value
  #   when :nmi then value < other.as_nautical_miles.value
  #   end
  # end

  # def <=(other)
  #   self < other || self == other
  # end

  # def >(other)
  #   !(self <= other)
  # end

  # def >=(other)
  #   self > other || self == other
  # end

  def to_s
    "#{value} #{unit}"
  end

  private

  def convert_to(target_unit, conversion_factors)
    Length.new((value / conversion_factors[unit]).round(4), target_unit)
  end
end

# Example

puts [Length.new(1, :mi), Length.new(1, :nmi), Length.new(1, :km)].sort
# => comparison of Length with Length failed (ArgumentError)
# expected output:
# 1 km
# 1 mi
# 1 nmi
```

The problem here is that the `sort` method need the implementation of a `<=>` for the type of the elements that need to be sorted: without it, Ruby doesn't know how to compare the elements. The solution is simple: we can just define a custom `<=>` instance method in the `Length` class, and mix in the module `Comparable`. This provides the right funcionality to allow the different instances of `Length` to be compared by `sort`. We can even remove all the other operator-like comparison methods if we want.

